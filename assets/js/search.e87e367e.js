(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{285:function(o,e,t){"use strict";t.r(e),e.default=[{title:"【读书笔记】《CSS揭秘》第一章 引言",path:"/posts/csssecret1.html",strippedContent:"## Web标准 制定Web标准不是闭门造车，而是一个透明公开的过程。对于哪些东西应该进入标准，浏览器厂商比W3C有更多的发言权。  CSS3是一个非正式的集合，包含以下模块： - CSS语法 - CSS层叠与继承 - CSS颜色 - 选择符 - CSS背景与边框 - CSS值与单位 - CSS文本排版 - CSS文本装饰效果 - CSS字体 - CSS基本UI特性  以及一些新加入的模块： - CSS变形 - 图像混合效果 - 滤镜效果 - CSS遮罩 - CSS伸缩盒布局 - CSS网格布局  ## CSS编码技巧 ### 尽量减少代码重复 软件开发中，代码的**DRY和可维护性**是极大的挑战。 保证代码的可维护性的关键：尽量减少改动时要编辑的地方，以提升开发效率并容易扩展。 #### 例子1（按钮） ```css padding: 6px 16px; border: 1px solid #446d88; background: #58a linear-gradient(#77a0bb, #58a); border-radius: 4px; box-shadow: 0 1px 5px gray; color: white; text-shadow: 0 -1px 1px #335166; font-size: 20px; line-height: 30px; ``` 可维护性方面的问题： 1. 字体尺寸。如果改变字号`font-size`就要同时修改`line-height`，**当某些值相互依赖时，就应该将他们的依赖关系用代码表达出来**，改成下面会更好： ```css font-size: 20px; line-height: 1.5; /* 表示line-height的值是font-size的1.5倍 */ ``` 绝对值难以掌控，每次的修改都会很繁琐。如果加大父级字号，为使按钮跟着变大，不得不修改每一处绝对值字号样式。 改用**百分比或em/rem**会更好： ```css font-size: 125%; /* 假设父级的字号是 16px */ line-height: 1.5; ``` 2. 其他尺寸。现在的代码在尺寸上仍有可维护性的问题：更改按钮尺寸之后，按钮整体会变得不协调，因为其他尺寸样式是绝对值。把这些尺寸都改成em单位就能解决这个问题。其他尺寸如果希望和当前元素的`font-size`大小关联使用em，如果希望和根级字号相关联使用rem。 ```css padding: .3em .8px; border: 1px solid #446d88; /* border仍使用px单位 */ background: #58a linear-gradient(#77a0bb, #58a); border-radius: .2em; box-shadow: 0 .05em .25em gray; color: white; text-shadow: 0 -.05em .05em #335166; font-size: 125%; line-height: 1.5; ``` 此时的大号按钮更像是原按钮等比例放大的版本了。总而言之，长度单位使用绝对值还是相对值，取决于哪些效果应该和按钮一起放大，而哪些需要保持不变。 3. 颜色。颜色也是一个重要的变数，比如设置一个红色的取消键或绿色的确认键。考虑1：对于不同的主色调，依据确定的变化程度衍生出不同的亮色和暗色。考虑2：投影需要根据按钮所在背景颜色变化。解决方案：把半透明的黑色或白色叠加在主色调上，即可相对应地产生主色调的暗色或亮色变体。 ```css padding: .3em .8px; border: 1px solid rgba(0,0,0,.1); background: #58a linear-gradient(hsla(0,0%,100%,.2), transparent); border-radius: .2em; box-shadow: 0 .05em .25em rgba(0,0,0,.5); color: white; text-shadow: 0 -.05em .05em rgba(0,0,0,.5); font-size: 125%; line-height: 1.5; ``` 现在只需要覆盖`background-color`属性就可以得到不同版本的按钮了。 ####其他技巧 1. 易维护 VS 代码量少 有时易维护和代码量少不可兼得。例子： ```css border-width: 10px 10px 10px 0; ``` 下面代码的可维护性和可读性都更好一些： ```css border-width: 10px; border-left-width: 0; ``` 2. currentColor CSS颜色中新增的颜色关键字--`currentColor`，它被解析为`color`属性的值。该特性使之成为CSS中的**变量**。例子： ```css hr { /* 水平分割线元素自动与文本的颜色保持一致 */     height: .5em;     background: currentColor; } ``` `currentColor`本身也是许多CSS颜色属性的初始值，如：`border-color`, `outline-color`, `text-shadow`, `box-shadow`的颜色值等。 3. inherit `inherit`关键字可用于任何CSS属性中，它总是绑定到父元素的计算值（对于伪元素则会取生成该伪元素的宿主元素）。 ### 相信你的眼睛而不是数字 视觉上的错觉在任何形式的视觉设计中都普遍存在，这时需要根据肉眼所见进行相应调整。 ### 关于响应式网页设计 怎样做好响应式设计？比较常见的实践是用多种分辨率来测试一个网站，然后添加媒体查询来修补各分辨率下产生的问题。但是**媒体查询增加了维护的成本**，因为未来每次对CSS的改动都要求我们逐一核对这些媒体查询是否需要配合修改。不是说媒体查询不好，只是应把它当做 The Last Resort 。因为媒体查询不能以一种连续的方式修复问题。他的工作原理基于某几个特定的断点。另外，媒体查询的断点不应该由具体的设备来决定，而应该由设计自身来决定。因为如果在任何视口尺寸下都能良好工作，就不需关心设备的分辨率。 "},{title:"Symbol数据类型简介",path:"/posts/symbol.html",strippedContent:"### Symbol数据类型 `symbol`是js中7种基础数据类型之一（基础数据类型包括：number, string, boolean, null, undefined, [bigint](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt), symbol），symbol是在ECMAScript 2015 / ES6中新加入的。在JavaScript运行环境中，调用函数`Symbol()`可以动态地返回一个匿名且唯一的`symbol`类型的值。接下来，这篇文章会简单介绍一下Symbol构造函数，well-known symbols，全局symbol注册表这三部分内容。 ### Symbol构造函数 `Symbol()`函数：构造一个symbol类型值并返回，该值唯一。 返回值：symbol类型值 它类似于内置的Object类，但不完全是一个构造器，因为它不支持`new Symbol()`这样的语法。 每一个从`Symbol()`函数返回的symbol值都是独一无二的，因为其唯一性，适合用作对象属性的标识符，使用`Object.getOwnPropertySymbols()` 以symbol数组的形式返回某个对象的所有symbol属性。  ``` js // Symbol()函数使用 const symbol1 = Symbol(); const symbol2 = Symbol(42); const symbol3 = Symbol('foo');  console.log(typeof symbol1); // expected output: \"symbol\"  console.log(symbol3.toString()); // expected output: \"Symbol(foo)\" // 唯一性 console.log(Symbol('foo') === Symbol('foo')); // expected output: false  const object1 = {}; // symbol用作对象属性的标识 object1[symbol1] = 'this is symbol1.'; object1[symbol2] = 'this is symbol2.'; object1[symbol3] = 'this is symbol3.'; // 获取某对象中所有的symbol属性 const objectSymbols = Object.getOwnPropertySymbols(object1); console.log(objectSymbols.length); // expected output: 3 ``` ### well-known symbols 即内置symbol，用来表示内部语言行为，分为3种：迭代symbol，正则symbol，其他symbol。 #### Iteration Symbols - `Symbol.iterator`是内置的迭代symbol，用来访问对象的`@@iterator`方法，该方法是对象默认迭代器的方法，可用于`for...of`循环，也可以说`@@iterator`为我们提供了重载`of`的方法。可迭代对象（`String`, `Array`, `TypedArray`, `Map`, `Set`, `arguments`对象等）拥有默认的`@@iterator`方法。对于不可迭代的`Object`，通过实现`Object`的`@@iterator`方法，就可以把不可迭代的对象转变为可迭代的对象。 ```js const iterable1 = new Object();  iterable1[Symbol.iterator] = function* () {   yield 1;   yield 2;   yield 3; };  console.log([...iterable1]); // [1, 2, 3] ``` - `Symbol.asyncIterator`是内置的迭代symbol，用来访问对象的`@@asyncIterator`方法，该方法实现的是对象默认异步迭代器的方法，可用于`for await...of`循环。 #### Regular Expression Symbols - `Symbol.match`是内置的正则symbol，用于访问对象的`@@match`方法，该方法用来判断给定的值是否和某个字符串匹配，在使用`String.prototype.match()`时被调用。也就是说我们可以用`@@match`方法来实现自定义的匹配方法。 ```js class MyMatcher {     constructor(value) {         this.value = value;     }     [Symbol.match](string) {         var index = string.indexOf(this.value);         if (index === -1) {             return null;         }         return [this.value];     } } var fooMatcher = 'foobar'.match(new MyMatcher('foo')); // ['foo'] var barMatcher = 'foobar'.match(new MyMatcher('bar')); // ['bar'] ``` - `Symbol.matchAll`是内置的正则symbol，用于访问对象的`@@matchAll`方法，该方法返回一个包括了所有匹配值的迭代器，在使用`String.prototype.matchAll()`时被调用。 - `Symbol.replace`是内置的正则symbol，用于访问对象的`@@replace`方法，该方法用来替换和某个字符串的子串匹配的部分，在使用`String.prototype.replace()`时被调用。 ```js class MyReplacer {     constructor(value) {         this.value = value;     }     [Symbol.replace](string, replacer) {         var index = string.indexOf(this.value);         if (index === -1) {             return string;         }         if (typeof replacer === 'function') {             replacer = replacer.call(undefined, this.value, string);         }         return `${string.slice(0, index)}${replacer}${string.slice(index + this.value.length)}`;     } } var fooReplaced = 'foobar'.replace(new MyReplacer('foo'), 'baz'); // 'bazbar' var barMatcher = 'foobar'.replace(new MyReplacer('bar'), function () { return 'baz' }); // 'foobaz' ``` - `Symbol.search`用于访问对象的`@@search`方法，在使用`String.prototype.search()`时被调用。 - `Symbol.split`用于访问对象的`@@split`方法，在使用`String.prototype.split()`时被调用。 正则symbol允许我们自定义类似于正则表达式的类。 #### Other Symbols - `Symbol.hasInstance`用于判断某个对象是否为某个构造器的实例，通过`instanceof`被调用。 ```js class Array1 {   static [Symbol.hasInstance](instance) {     return Array.isArray(instance);   } }  console.log([] instanceof Array1); // expected output: true ``` - `Symbol.isConcatSpreadable`用来访问对象的`@@isConcatSpreadable`属性，该属性为布尔值，用来配置一个数组对象在作为`Array.prototype.concat()`方法的参数时是否应该展开它的元素。 ```js var alpha = ['a', 'b', 'c'],      numeric = [1, 2, 3];   var alphaNumeric = alpha.concat(numeric);  console.log(alphaNumeric); // 结果: ['a', 'b', 'c', 1, 2, 3]  numeric[Symbol.isConcatSpreadable] = false; alphaNumeric = alpha.concat(numeric); console.log(alphaNumeric); // 结果: ['a', 'b', 'c', [1, 2, 3] ] ``` - `Symbol.unscopables`用来访问对象的`@@unscopables`属性，该属性为对象值，通过设置某个对象的这个属性，就可以把对象的自有属性及继承属性排除在`with`作用域之外。 ```js const object1 = {   property1: 42 };  object1[Symbol.unscopables] = {   property1: true };  with (object1) {   console.log(property1);   // expected output: Error: property1 is not defined } ``` - `Symbol.species`用来访问对象的`@@species`方法，该属性值为函数，该函数会在创建派生对象 (derived object) 时作为其构造函数。派生对象是相对于原始对象而言的，原始对象在某些具体的操作（如`map`）之后得到的对象被称为派生对象。一般情况下，派生对象和原始对象有着相同的构造器。而如果我们想为派生对象自定义一个构造器时，`@@species`方法就派上用场了。举个例子，我希望给`Array`类添加一些其他的方法，那么我可以基于父类`Array`继承得到子类`MyArray`。之后，`MyArray`的某个实例使用了`map()`方法，如果我希望`map()`方法返回的新对象是`Array`类的实例而不是`MyArray`类的实例，通过实现`MyArray`类的`@@species`方法可以达到目的。 ```js class MyArray extends Array {     isEmpty() {     return this.length === 0;   }   static get [Symbol.species]() {     return Array;   } } let array = new MyArray(3, 5, 4);   array.isEmpty(); // => false   let odds = array.filter(item => item % 2 === 1);   odds instanceof Array;   // => true   odds instanceof MyArray; // => false ``` - `Symbol.toPrimitive`用来访问对象的`@@toPrimitive`方法，当对象需要转化为基本数据类型的时候就会调用该方法。举个例子，在做`+obj`运算时js会调用`obj[Symbol.toPrimitive]('number')`；在做`'obj'`运算时js会调用`obj[Symbol.toPrimitive]('string')`。 ```js var obj = {   [Symbol.toPrimitive](hint) {     if (hint == 'number') {       return 10;     }     if (hint == 'string') {       return 'hello';     }     return true;   } }; console.log(+obj);     // 10        -- hint is \"number\" console.log(`${obj}`); // \"hello\"   -- hint is \"string\" console.log(obj + ''); // \"true\"    -- hint is \"default\" ``` - `Symbol.toStringTag`用来访问对象的`@@toStringTag`属性，该属性返回一个字符串，用于设置对象默认的字符串描述。在使用`Object.prototype.toString()`方法时，`Object.prototype.toString()`方法首先会检查作为参数传入的对象是否存在`@@toStringTag`属性，如果有则用于最后返回的字符串中。 ```js class Collection {   get [Symbol.toStringTag]() {     return 'Collection';   } } var x = new Collection(); Object.prototype.toString.call(x) === '[object Collection]' // true ```  ### global symbol registry 即全局symbol注册表，表中的每一项称之为Record，每个record包含两个字段：key（字符串类型，用作symbol的标识）, symbol（symbol类型，存储的symbol值）。在全局symbol注册表中的symbol可在全局访问到。 - `Symbol.for(key)`函数，在全局symbol注册表中根据key值查询对应的symbol并返回；查询不到则创建一个可在全局symbol注册表中访问到的symbol。 - `Symbol.keyFor(sym)`函数，返回symbol在全局symbol注册表中对应的key值；没有对应的key值则返回`undefined`。  ### 浏览器兼容性  [symbol的浏览器兼容性](http://kangax.github.io/compat-table/es6/#test-Symbol) ### 总结 symbol是ES6中新引入的基本数据类型，可通过Symbol构造函数创建得到唯一的symbol值，well-known symbols可以让开发人员自定义类及对象的行为，如迭代、字符串匹配查找等。 "}]}}]);